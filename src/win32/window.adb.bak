with Interfaces.C.Strings;
with Interfaces;
with System;
with Ada.Text_IO; use Ada.Text_IO;

with Ada.Unchecked_Conversion;

package body Window is

   package IC renames interfaces.C;

   WS_OVERLAPPEDWINDOW : constant := 16#cf0000#;
   WS_VISIBLE : constant := 16#10000000#;

   CS_VREDRAW : constant := 16#1#;
   CS_HREDRAW : constant := 16#2#;

   SW_SHOW    : constant := 5;

   WM_DESTROY : constant := 16#2#;

   WHITE_BRUSH : constant := 0;

   type LPSTR is access all IC.char;

   IDI_APPLICATION : LPSTR;
   IDC_ARROW       : LPSTR;

   type LPCSTR is access constant IC.char;

   subtype PVOID is System.Address;
   subtype HANDLE is PVOID;
   subtype LPVOID is PVOID;
   subtype HWND is HANDLE;
   subtype DWORD is IC.unsigned_long;
   subtype HMENU is HANDLE;
   subtype HINSTANCE is HANDLE;
   subtype HICON is HANDLE;
   subtype HCURSOR is HANDLE;
   subtype HBRUSH is HANDLE;
   subtype HGDIOBJ is HANDLE;

   type ATOM is new IC.unsigned_short;

   type WPARAM is mod 2 ** Standard'Address_Size;

   type LONG_PTR is
     range -(2 ** (Standard'Address_Size - 1))
           .. +(2 ** (Standard'Address_Size - 1) - 1);
   subtype LPARAM is LONG_PTR;
   subtype LRESULT is LONG_PTR;

   type WNDPROC is
     access function
       (H_Wnd : HWND; 
        Msg : IC.unsigned; 
        W_Param : WPARAM; 
        L_Param : LPARAM)
        return LRESULT;

   type WNDCLASS is record
      Style           : IC.unsigned;
      Lp_fn_Wnd_Proc  : WNDPROC;
      Cb_Cls_Extra    : IC.int;
      Cb_Wnd_Extra    : IC.int;
      H_Instance      : HINSTANCE;
      H_Icon          : HICON;
      H_Cursor        : HCURSOR;
      H_br_Background : HBRUSH;
      Lpsz_Menu_Name  : LPCSTR;
      Lpsz_Class_Name : LPCSTR;
   end record;
   type WNDCLASS_Access is access all WNDCLASS;

   type String_Access is access all String;

   function Create_Window
     (Dw_Ex_Style    : DWORD;
      Lp_Class_Name  : LPCSTR;
      Lp_Window_Name : LPCSTR;
      Dw_Style       : DWORD;
      X              : IC.int;
      Y              : IC.int;
      Width          : IC.int;
      Height         : IC.int;
      H_Wnd_Parent   : HWND;
      H_Menu         : HMENU;
      H_Instance     : HINSTANCE;
      Lp_Param       : LPVOID) return HWND
   with Import => True, Convention => C, External_Name => "CreateWindowExA";

   function Get_H_Instance return HINSTANCE is
      function Retrieve_H_Instance return HINSTANCE;
      pragma Import (C, Retrieve_H_Instance, "rts_get_hInstance");
   begin
      return Retrieve_H_Instance;
   end;

   H_Instance : HINSTANCE := Get_H_Instance;

   --  Class_Name    : String_Access := new String'("Core");
   --  Lp_Class_Name : LPCSTR with Address => Class_Name'Address;
   --  Menu_Name     : String_Access := new String'("");
   --  Lp_Menu_Name  : LPCSTR with Address => Menu_Name'Address;

   function CHARPTR_TO_LPCSTR is new Ada.Unchecked_Conversion (IC.Strings.chars_ptr, LPCSTR);

   use Interfaces.C.Strings;
   --title : Interfaces.C.Strings.chars_ptr := New_String (Ada.Strings.Unbounded.To_String(window.title));
   --APPTITLE     : Win32.LPCSTR := CHARPTR_TO_LPCSTR(title);
   class    : IC.Strings.chars_ptr := New_String ("Core");
   Lp_Class_Name : LPCSTR := CHARPTR_TO_LPCSTR (class);

   function Load_Icon
     (H_Instance : HINSTANCE; Lp_Icon_Name : LPCSTR) return HICON
   with Import => True, Convention => C, External_Name => "LoadIconA";

   function Load_Cursor
     (H_Instance : HINSTANCE; Lp_Cursor_Name : LPCSTR) return HCURSOR
   with Import => True, Convention => C, External_Name => "LoadCursorA";

   function Get_Stock_Object (Fn_Object : IC.int) return HGDIOBJ
   with Import => True, Convention => C, External_Name => "GetStockObject";

   function Register_Class (Lp_Wnd_Class : access WNDCLASS) return ATOM
   with Import => True, Convention => C, External_Name => "RegisterClassW";

   procedure Post_Quit_Message (N_Exit_Code : IC.int)
   with Import => True, Convention => C, External_Name => "PostQuitMessage";

   function Def_Window_Proc
     (H_Wnd   : HWND;
      Msg     : IC.unsigned;
      W_Param : WPARAM;
      L_Param : LPARAM)
      return LRESULT
    with Import => True, Convention => C, External_Name => "DefWindowProcA";

   function Wnd_Proc (H_Wnd : HWND; 
                      Msg : IC.unsigned; 
                      W_Param : WPARAM; 
                      L_Param : LPARAM) return LRESULT is
   begin
        case Msg is
            when WM_DESTROY =>
                Post_Quit_Message (0);
            when others =>
                return Def_Window_Proc(H_Wnd, Msg, W_Param, L_Param);
        end case;
        return 0;
   end Wnd_Proc;

   function Register_Window_Class return Boolean is
      WC : WNDCLASS_Access := new WNDCLASS;
      A  : ATOM;
      use IC;
   begin
      --WC.Style := CS_VREDRAW or CS_HREDRAW;
      WC.Lp_fn_Wnd_Proc := Wnd_Proc'Access;
      --WC.Cb_Cls_Extra := 0;
      --WC.Cb_Wnd_Extra := 0;
      WC.H_Instance := H_Instance;
     -- WC.H_Icon := Load_Icon (System.Null_Address, LPCSTR (IDI_APPLICATION));
      --WC.H_Cursor := Load_Cursor (System.Null_Address, LPCSTR (IDC_ARROW));
      WC.H_br_Background := HBRUSH (Get_Stock_Object (WHITE_BRUSH));
      --WC.Lpsz_Menu_Name := Lp_Menu_Name;
      WC.Lpsz_Class_Name := Lp_Class_Name;
      A := Register_Class (WC);
      Put_Line ("Register_Class result: " & A'Image);
      return True;
   end;

   function Show_Window (H_Wnd : HWND; N_Cmd_Show : IC.int) return Boolean
   with Import => True, Convention => C, External_Name => "ShowWindow";

   procedure Window is
      Window_Name    : String_Access := new String'("Ada Window");
      Lp_Window_Name : LPCSTR with Address => Window_Name'Address;
      use IC;
      Registered     : Boolean := Register_Window_Class;
      Win            : HWND :=
           Create_Window
             (0,
              Lp_Class_Name,
              Lp_Window_Name,
              WS_OVERLAPPEDWINDOW or WS_VISIBLE,
              100,
              100,
              250,
              250,
              System.Null_Address,
              System.Null_Address,
              H_Instance,
              System.Null_Address);
        SW : Boolean := Show_Window (Win, SW_SHOW);
   begin
      Put_Line ("Win: " & Win'Image);
      Put_Line ("Show_Window: " & SW'Image);
      while SW loop
         delay 0.1;
      end loop;
   end;
end Window;
